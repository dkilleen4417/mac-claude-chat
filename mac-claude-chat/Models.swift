//
//  Models.swift
//  mac-claude-chat
//
//  Created by Drew on 2/5/26.
//
//  CloudKit-compatible SwiftData models.
//  Requirements: no @Attribute(.unique), all properties have defaults,
//  all relationships are optional.
//

import Foundation
import SwiftData

// MARK: - App Configuration

/// Manual version tracking for SwiftData schema changes.
/// Bump this BEFORE any schema change, deploy to ALL devices first.
enum AppConfig {
    static let buildVersion = 8  // Bumped for ChatMessage.isEdited field
}

// MARK: - SwiftData Persistent Models (CloudKit-Compatible)

@Model
final class ChatSession {
    // CloudKit: removed @Attribute(.unique) â€” uniqueness enforced in app logic
    var chatId: String = ""
    var totalInputTokens: Int = 0
    var totalOutputTokens: Int = 0
    var lastUpdated: Date = Date()
    var isDefault: Bool = false
    
    /// Context management: minimum grade threshold for including messages (0-5)
    /// Messages with textGrade < threshold are excluded from context
    /// Default 0 = include all messages (current behavior)
    var contextThreshold: Int = 0
    
    // CloudKit: relationship must be optional
    @Relationship(deleteRule: .cascade, inverse: \ChatMessage.session)
    var messages: [ChatMessage]? = []
    
    init(
        chatId: String,
        totalInputTokens: Int = 0,
        totalOutputTokens: Int = 0,
        lastUpdated: Date = Date(),
        isDefault: Bool = false,
        contextThreshold: Int = 0,
        messages: [ChatMessage] = []
    ) {
        self.chatId = chatId
        self.totalInputTokens = totalInputTokens
        self.totalOutputTokens = totalOutputTokens
        self.lastUpdated = lastUpdated
        self.isDefault = isDefault
        self.contextThreshold = contextThreshold
        self.messages = messages
    }
    
    /// Safe accessor for messages (unwraps optional for CloudKit compatibility)
    var safeMessages: [ChatMessage] {
        get { messages ?? [] }
        set { messages = newValue }
    }
}

@Model
final class ChatMessage {
    var messageId: String = ""
    var role: String = ""
    var content: String = ""
    var timestamp: Date = Date()
    
    /// Context management: relevance grade for text content (0-5, default 5)
    /// Messages with textGrade < chat's contextThreshold are excluded from API calls
    var textGrade: Int = 5
    
    /// Context management: relevance grade for image content (0-5, default 5)
    /// Images with imageGrade < threshold are excluded (Phase 2 - currently rides with text)
    var imageGrade: Int = 5
    
    /// Turn identity: UUID string shared by all messages in the same turn
    /// Empty string for legacy messages (will be backfilled on migration)
    var turnId: String = ""
    
    /// Distinguishes final assistant response from intermediate tool loop messages
    /// True for user messages and final assistant responses; false for tool_use/tool_result intermediates
    var isFinalResponse: Bool = true
    
    /// Per-turn token tracking: input tokens for this turn's API call
    var inputTokens: Int = 0
    
    /// Per-turn token tracking: output tokens for this turn's API response
    var outputTokens: Int = 0
    
    /// Iceberg tip: one-line compressed summary of this turn's exchange
    /// Generated by the primary conversation call, used by the router for context
    var icebergTip: String = ""
    
    /// Which model generated this response (stored as raw enum value)
    /// Empty string for user messages and legacy messages
    var modelUsed: String = ""
    
    /// Whether this message has been edited after initial creation
    var isEdited: Bool = false
    
    // CloudKit: already optional â€” good
    var session: ChatSession?
    
    init(
        messageId: String = UUID().uuidString,
        role: String,
        content: String,
        timestamp: Date = Date(),
        textGrade: Int = 5,
        imageGrade: Int = 5,
        turnId: String = "",
        isFinalResponse: Bool = true,
        inputTokens: Int = 0,
        outputTokens: Int = 0,
        icebergTip: String = "",
        modelUsed: String = "",
        isEdited: Bool = false
    ) {
        self.messageId = messageId
        self.role = role
        self.content = content
        self.timestamp = timestamp
        self.textGrade = textGrade
        self.imageGrade = imageGrade
        self.turnId = turnId
        self.isFinalResponse = isFinalResponse
        self.inputTokens = inputTokens
        self.outputTokens = outputTokens
        self.icebergTip = icebergTip
        self.modelUsed = modelUsed
        self.isEdited = isEdited
    }
}

// MARK: - Web Tools Models

/// A category of web tool sources (e.g., "Weather", "Finance").
/// Groups related WebToolSource records under a single intent keyword.
@Model
final class WebToolCategory {
    var categoryId: String = UUID().uuidString
    var name: String = ""
    var keyword: String = ""
    var extractionHint: String = ""
    var iconName: String = "globe"
    var isEnabled: Bool = true
    var displayOrder: Int = 0
    var createdAt: Date = Date()

    // CloudKit: relationship must be optional
    @Relationship(deleteRule: .cascade, inverse: \WebToolSource.category)
    var sources: [WebToolSource]? = []

    init(
        categoryId: String = UUID().uuidString,
        name: String = "",
        keyword: String = "",
        extractionHint: String = "",
        iconName: String = "globe",
        isEnabled: Bool = true,
        displayOrder: Int = 0,
        createdAt: Date = Date(),
        sources: [WebToolSource] = []
    ) {
        self.categoryId = categoryId
        self.name = name
        self.keyword = keyword
        self.extractionHint = extractionHint
        self.iconName = iconName
        self.isEnabled = isEnabled
        self.displayOrder = displayOrder
        self.createdAt = createdAt
        self.sources = sources
    }

    /// Safe accessor for sources (unwraps optional for CloudKit compatibility)
    var safeSources: [WebToolSource] {
        get { sources ?? [] }
        set { sources = newValue }
    }
}

/// A single web source within a WebToolCategory.
/// Priority determines fallback order: 1 = primary, 2 = secondary, 3 = tertiary.
@Model
final class WebToolSource {
    var sourceId: String = UUID().uuidString
    var name: String = ""
    var urlPattern: String = ""
    var extractionHint: String = ""
    var priority: Int = 1
    var isEnabled: Bool = true
    var notes: String = ""
    var createdAt: Date = Date()

    // CloudKit: relationship must be optional
    var category: WebToolCategory?

    init(
        sourceId: String = UUID().uuidString,
        name: String = "",
        urlPattern: String = "",
        extractionHint: String = "",
        priority: Int = 1,
        isEnabled: Bool = true,
        notes: String = "",
        createdAt: Date = Date()
    ) {
        self.sourceId = sourceId
        self.name = name
        self.urlPattern = urlPattern
        self.extractionHint = extractionHint
        self.priority = priority
        self.isEnabled = isEnabled
        self.notes = notes
        self.createdAt = createdAt
    }
}

// MARK: - In-Memory Models

struct Message: Identifiable {
    let id: UUID
    let role: Role
    let content: String
    let timestamp: Date
    var textGrade: Int
    var imageGrade: Int
    var turnId: String
    var isFinalResponse: Bool
    var inputTokens: Int
    var outputTokens: Int
    var icebergTip: String
    var modelUsed: String
    var isEdited: Bool
    
    init(id: UUID = UUID(), role: Role, content: String, timestamp: Date = Date(), textGrade: Int = 5, imageGrade: Int = 5, turnId: String = "", isFinalResponse: Bool = true, inputTokens: Int = 0, outputTokens: Int = 0, icebergTip: String = "", modelUsed: String = "", isEdited: Bool = false) {
        self.id = id
        self.role = role
        self.content = content
        self.timestamp = timestamp
        self.textGrade = textGrade
        self.imageGrade = imageGrade
        self.turnId = turnId
        self.isFinalResponse = isFinalResponse
        self.inputTokens = inputTokens
        self.outputTokens = outputTokens
        self.icebergTip = icebergTip
        self.modelUsed = modelUsed
        self.isEdited = isEdited
    }
    
    enum Role {
        case user
        case assistant
    }
}

struct ChatMetadata {
    let chatId: String
    let totalInputTokens: Int
    let totalOutputTokens: Int
    let lastUpdated: Date
    let isDefault: Bool
}

struct ChatInfo: Identifiable, Equatable {
    let id: String
    let name: String
    let lastUpdated: Date
    let isDefault: Bool
    
    static func == (lhs: ChatInfo, rhs: ChatInfo) -> Bool {
        lhs.id == rhs.id
    }
}

// MARK: - Claude Model Configuration

enum ClaudeModel: String, CaseIterable, Identifiable {
    case turbo = "claude-haiku-4-5-20251001"
    case fast = "claude-sonnet-4-5-20250929"
    case premium = "claude-opus-4-6"
    
    var id: String { rawValue }
    
    var displayName: String {
        switch self {
        case .turbo: return "Haiku 4.5"
        case .fast: return "Sonnet 4.5"
        case .premium: return "Opus 4.6"
        }
    }
    
    var emoji: String {
        switch self {
        case .turbo: return "ðŸ’¨"
        case .fast: return "âš¡"
        case .premium: return "ðŸš€"
        }
    }
    
    var inputCostPerMillion: Double {
        switch self {
        case .turbo: return 0.80
        case .fast: return 3.00
        case .premium: return 5.00
        }
    }
    
    var outputCostPerMillion: Double {
        switch self {
        case .turbo: return 4.00
        case .fast: return 15.00
        case .premium: return 25.00
        }
    }
}

// MARK: - Router Types

/// Response from the Haiku router classification call
struct RouterResponse {
    let tier: ClaudeModel
    let confidence: Double
}

// MARK: - Notification Names

extension Notification.Name {
    static let newChat = Notification.Name("newChat")
    static let clearChat = Notification.Name("clearChat")
    static let deleteChat = Notification.Name("deleteChat")
    static let showAPIKeySettings = Notification.Name("showAPIKeySettings")
    static let publishChat = Notification.Name("publishChat")
    static let showWebToolManager = Notification.Name("showWebToolManager")
}
